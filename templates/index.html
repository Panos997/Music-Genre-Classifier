<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <title>AI Music Genre Predictor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; text-align: center; padding: 40px; background: #f4f4f9; color: #333; }
        .container { background: white; padding: 30px; border-radius: 20px; display: inline-block; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 100%; max-width: 500px; }
        #progressContainer { width: 100%; background: #eee; border-radius: 10px; margin: 20px 0; display: none; overflow: hidden; }
        #progressBar { width: 0%; height: 25px; background: #1db954; color: white; line-height: 25px; font-weight: bold; transition: background-color 0.4s; }
        .result-text { margin-top: 20px; font-size: 1.1em; }
        button { background: #1db954; color: white; border: none; padding: 12px 30px; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold; margin-top: 10px; }
        button:hover { background: #1ed760; }
        canvas { margin-top: 20px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>ğŸµ Music Genre AI</h1>
        <p>ÎˆÎ¾Ï…Ï€Î½Î· Î±Î½Î¬Î»Ï…ÏƒÎ· (Î‘ÏÏ‡Î®, ÎœÎ­ÏƒÎ·, Î¤Î­Î»Î¿Ï‚)</p>
        
        <input type="file" id="audioFile" accept="audio/*">
        <br>
        <button onclick="processAndUpload()">Î ÏÏŒÎ²Î»ÎµÏˆÎ·!</button>

        <div id="progressContainer">
            <div id="progressBar">Î ÏÎ¿ÎµÏ„Î¿Î¹Î¼Î±ÏƒÎ¯Î±...</div>
        </div>

        <div id="results" class="result-text"></div>
        <canvas id="genreChart"></canvas>
    </div>

    <script>
        let myChart = null;

        async function processAndUpload() {
            const fileInput = document.getElementById('audioFile');
            const progBar = document.getElementById('progressBar');
            const progContainer = document.getElementById('progressContainer');
            const resultsDiv = document.getElementById('results');

            if (!fileInput.files[0]) return alert("Î Î±ÏÎ±ÎºÎ±Î»Ï ÎµÏ€Î¯Î»ÎµÎ¾Îµ Î­Î½Î± Î±ÏÏ‡ÎµÎ¯Î¿!");

            progContainer.style.display = "block";
            progBar.style.width = "100%"; // Î“Î¹Î± Ï„Î·Î½ Ï€ÏÎ¿ÎµÏ„Î¿Î¹Î¼Î±ÏƒÎ¯Î±
            progBar.style.backgroundColor = "#555";
            progBar.innerHTML = "Î•Ï€ÎµÎ¾ÎµÏÎ³Î±ÏƒÎ¯Î± Î´ÎµÎ¯Î³Î¼Î±Ï„Î¿Ï‚...";

            try {
                const trimmedBlob = await createSmartSample(fileInput.files[0]);
                const formData = new FormData();
                formData.append('file', trimmedBlob, "sample.wav");

                const xhr = new XMLHttpRequest();
                
                // 1. Î¦Î‘Î£Î— UPLOAD
                xhr.upload.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        progBar.style.width = percent + "%";
                        progBar.style.backgroundColor = "#1db954";
                        progBar.innerHTML = "Uploading: " + percent + "%";
                    }
                };

                // 2. ÎœÎŸÎ›Î™Î£ Î¤Î•Î›Î•Î™Î©Î£Î•Î™ Î¤ÎŸ UPLOAD Î‘Î›Î›Î‘ Î Î¡Î™Î Î¤Î—Î Î‘Î Î‘ÎÎ¤Î—Î£Î—
                xhr.upload.onload = () => {
                    progBar.style.width = "100%";
                    progBar.style.backgroundColor = "#ffa500"; // Î Î¿ÏÏ„Î¿ÎºÎ±Î»Î¯
                    progBar.innerHTML = "AI: Î•ÏÎ¼Î·Î½ÎµÎ¯Î± Ï„ÏÎ±Î³Î¿Ï…Î´Î¹Î¿Ï...";
                };

                // 3. ÎŸÎ¤Î‘Î Î•Î¡Î˜ÎŸÎ¥Î Î¤Î‘ Î‘Î ÎŸÎ¤Î•Î›Î•Î£ÎœÎ‘Î¤Î‘
                xhr.onload = () => {
                    if (xhr.status === 200) {
                        const data = JSON.parse(xhr.responseText);
                        
                        // Î ÏÏÏ„Î± ÎµÎ¼Ï†Î±Î½Î¯Î¶Î¿Ï…Î¼Îµ Ï„Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î±
                        renderChart(data);
                        showResults(data);

                        // ÎœÎµÏ„Î¬ Î±Î»Î»Î¬Î¶Î¿Ï…Î¼Îµ Ï„Î·Î½ Î¼Ï€Î¬ÏÎ± ÏƒÎµ "ÎŸÎ»Î¿ÎºÎ»Î·ÏÏÎ¸Î·ÎºÎµ"
                        progBar.style.backgroundColor = "#1db954"; // Î ÏÎ¬ÏƒÎ¹Î½Î¿ Ï€Î¬Î»Î¹
                        progBar.innerHTML = "ÎŸÎ»Î¿ÎºÎ»Î·ÏÏÎ¸Î·ÎºÎµ!";
                    } else {
                        progBar.style.backgroundColor = "red";
                        progBar.innerHTML = "Î£Ï†Î¬Î»Î¼Î± AI";
                    }
                };

                xhr.open("POST", "/predict");
                xhr.send(formData);

            } catch (err) {
                console.error(err);
                progBar.style.backgroundColor = "red";
                progBar.innerHTML = "Î£Ï†Î¬Î»Î¼Î± Î±ÏÏ‡ÎµÎ¯Î¿Ï…";
            }
        }

        async function createSmartSample(file) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            const sampleSecs = 10;
            const rate = audioBuffer.sampleRate;
            const chunkLen = sampleSecs * rate;
            const totalLen = audioBuffer.length;

            const startPos = 0;
            const midPos = Math.max(0, Math.floor(totalLen / 2) - Math.floor(chunkLen / 2));
            const endPos = Math.max(0, totalLen - chunkLen);

            const newBuffer = audioCtx.createBuffer(audioBuffer.numberOfChannels, chunkLen * 3, rate);
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const oldData = audioBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                newData.set(oldData.slice(startPos, startPos + chunkLen), 0);
                newData.set(oldData.slice(midPos, midPos + chunkLen), chunkLen);
                newData.set(oldData.slice(endPos, endPos + chunkLen), chunkLen * 2);
            }
            return bufferToWav(newBuffer);
        }

        function bufferToWav(abuffer) {
            let numOfChan = abuffer.numberOfChannels, length = abuffer.length * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length), view = new DataView(buffer),
                channels = [], i, sample, offset = 0, pos = 0;
            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
            setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157);
            setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
            setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
            setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164);
            setUint32(length - pos - 4);
            for(i=0; i<abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));
            while(pos < length) {
                for(i=0; i<numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
                    view.setInt16(pos, sample, true); pos += 2;
                }
                offset++;
            }
            return new Blob([buffer], {type: "audio/wav"});
        }

        function showResults(data) {
            const div = document.getElementById('results');
            div.innerHTML = `<h3>Top 3 Î ÏÎ¿Î²Î»Î­ÏˆÎµÎ¹Ï‚:</h3>` + 
                data.map((item, idx) => `<p>${idx+1}. ${item.genre}: ${item.probability}%</p>`).join('');
        }

        function renderChart(data) {
            const ctx = document.getElementById('genreChart').getContext('2d');
            if (myChart) myChart.destroy();
            myChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: data.map(i => i.genre),
                    datasets: [{
                        data: data.map(i => i.probability),
                        backgroundColor: ['#1db954', '#1ed760', '#81b71a'],
                        borderColor: '#fff',
                        borderWidth: 2
                    }]
                },
                options: { responsive: true, plugins: { legend: { position: 'bottom' } } }
            });
        }
    </script>
</body>
</html>
