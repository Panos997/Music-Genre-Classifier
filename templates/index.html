<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <title>AI Music Genre Predictor | Premium</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Modern Gradient Background */
        body { 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            text-align: center; 
            padding: 40px; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); 
            min-height: 100vh;
            margin: 0;
            color: #2d3436; 
        }

        .container { 
            background: white; 
            padding: 40px; 
            border-radius: 30px; 
            display: inline-block; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.1); 
            width: 100%; 
            max-width: 550px; 
            border: 1px solid rgba(255,255,255,0.8);
        }

        h1 { font-size: 2.2em; margin-bottom: 10px; color: #1e272e; }
        p { color: #7f8c8d; margin-bottom: 30px; }

        /* Custom Progress Bar */
        #progressContainer { 
            width: 100%; 
            background: #dfe6e9; 
            border-radius: 50px; 
            margin: 25px 0; 
            display: none; 
            overflow: hidden; 
            height: 28px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
        }

        #progressBar { 
            width: 0%; 
            height: 100%; 
            background: linear-gradient(90deg, #1db954, #1ed760); 
            color: white; 
            line-height: 28px; 
            font-weight: 600; 
            font-size: 13px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
        }

        /* Styled Button */
        button { 
            background: linear-gradient(to right, #1db954, #191414); 
            color: white; 
            border: none; 
            padding: 15px 40px; 
            border-radius: 50px; 
            cursor: pointer; 
            font-size: 18px; 
            font-weight: bold; 
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 10px 20px rgba(29, 185, 84, 0.3);
        }

        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 15px 25px rgba(29, 185, 84, 0.4);
        }

        button:active { transform: translateY(0); }

        .result-text { margin-top: 30px; }
        .result-item { 
            background: #f1f2f6; 
            margin: 5px 0; 
            padding: 10px; 
            border-radius: 12px;
            font-weight: 600;
        }

        canvas { margin-top: 30px; max-width: 100% !important; }
    </style>
</head>
<body>

    <div class="container">
        <h1>ğŸµ Music Genre AI</h1>
        <p>ÎˆÎ¾Ï…Ï€Î½Î· Î±Î½Î¬Î»Ï…ÏƒÎ· 3 ÏƒÎ·Î¼ÎµÎ¯Ï‰Î½ (Deep Scan)</p>
        
        <input type="file" id="audioFile" accept="audio/*" style="display: none;">
        <label for="audioFile" style="cursor: pointer; background: #eee; padding: 10px 20px; border-radius: 10px; display: block; margin-bottom: 20px;">
            ğŸ“ Î•Ï€Î¹Î»Î¿Î³Î® MP3
        </label>
        
        <button onclick="processAndUpload()">ÎˆÎ½Î±ÏÎ¾Î· Î ÏÏŒÎ²Î»ÎµÏˆÎ·Ï‚</button>

        <div id="progressContainer">
            <div id="progressBar">Î ÏÎ¿ÎµÏ„Î¿Î¹Î¼Î±ÏƒÎ¯Î±...</div>
        </div>

        <div id="results" class="result-text"></div>
        <canvas id="genreChart"></canvas>
    </div>

    <script>
        let myChart = null;

        // ÎŸÏÎ¹ÏƒÎ¼ÏŒÏ‚ Gradient Î Î±Î»Î­Ï„Î±Ï‚
        const chartColors = [
            { start: '#1db954', end: '#1ed760' }, // Spotify Green
            { start: '#00b894', end: '#55efc4' }, // Mint
            { start: '#2d3436', end: '#636e72' }  // Dark Gray
        ];

        async function processAndUpload() {
            const fileInput = document.getElementById('audioFile');
            const progBar = document.getElementById('progressBar');
            const progContainer = document.getElementById('progressContainer');
            const resultsDiv = document.getElementById('results');

            if (!fileInput.files[0]) return alert("Î Î±ÏÎ±ÎºÎ±Î»Ï ÎµÏ€Î¯Î»ÎµÎ¾Îµ Î­Î½Î± Î±ÏÏ‡ÎµÎ¯Î¿!");

            progContainer.style.display = "block";
            progBar.style.width = "100%";
            progBar.style.background = "#636e72";
            progBar.innerHTML = "Î•Ï€ÎµÎ¾ÎµÏÎ³Î±ÏƒÎ¯Î± Î´ÎµÎ¯Î³Î¼Î±Ï„Î¿Ï‚...";

            try {
                const trimmedBlob = await createSmartSample(fileInput.files[0]);
                const formData = new FormData();
                formData.append('file', trimmedBlob, "sample.wav");

                const xhr = new XMLHttpRequest();
                
                xhr.upload.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        progBar.style.width = percent + "%";
                        progBar.style.background = "linear-gradient(90deg, #1db954, #1ed760)";
                        progBar.innerHTML = "Î‘Î½Î­Î²Î±ÏƒÎ¼Î±: " + percent + "%";
                    }
                };

                xhr.upload.onload = () => {
                    progBar.style.width = "100%";
                    progBar.style.background = "linear-gradient(90deg, #f39c12, #f1c40f)"; // Î Î¿ÏÏ„Î¿ÎºÎ±Î»Î¯ Gradient
                    progBar.innerHTML = "AI: Î•ÏÎ¼Î·Î½ÎµÎ¯Î± Ï„ÏÎ±Î³Î¿Ï…Î´Î¹Î¿Ï...";
                };

                xhr.onload = () => {
                    if (xhr.status === 200) {
                        const data = JSON.parse(xhr.responseText);
                        renderChart(data);
                        showResults(data);
                        progBar.style.background = "linear-gradient(90deg, #00b894, #55efc4)"; // Mint Î ÏÎ¬ÏƒÎ¹Î½Î¿
                        progBar.innerHTML = "ÎŸÎ»Î¿ÎºÎ»Î·ÏÏÎ¸Î·ÎºÎµ!";
                    } else {
                        progBar.style.background = "#ff7675";
                        progBar.innerHTML = "Î£Ï†Î¬Î»Î¼Î± AI";
                    }
                };

                xhr.open("POST", "/predict");
                xhr.send(formData);

            } catch (err) {
                console.error(err);
                progBar.style.background = "#ff7675";
                progBar.innerHTML = "Î£Ï†Î¬Î»Î¼Î± Î±ÏÏ‡ÎµÎ¯Î¿Ï…";
            }
        }

        // ... (ÎŸÎ¹ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ createSmartSample ÎºÎ±Î¹ bufferToWav Ï€Î±ÏÎ±Î¼Î­Î½Î¿Ï…Î½ Î¯Î´Î¹ÎµÏ‚ Î¼Îµ Ï€ÏÎ¹Î½) ...
        async function createSmartSample(file) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            const sampleSecs = 10;
            const rate = audioBuffer.sampleRate;
            const chunkLen = sampleSecs * rate;
            const totalLen = audioBuffer.length;
            const startPos = 0;
            const midPos = Math.max(0, Math.floor(totalLen / 2) - Math.floor(chunkLen / 2));
            const endPos = Math.max(0, totalLen - chunkLen);
            const newBuffer = audioCtx.createBuffer(audioBuffer.numberOfChannels, chunkLen * 3, rate);
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const oldData = audioBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                newData.set(oldData.slice(startPos, startPos + chunkLen), 0);
                newData.set(oldData.slice(midPos, midPos + chunkLen), chunkLen);
                newData.set(oldData.slice(endPos, endPos + chunkLen), chunkLen * 2);
            }
            return bufferToWav(newBuffer);
        }

        function bufferToWav(abuffer) {
            let numOfChan = abuffer.numberOfChannels, length = abuffer.length * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length), view = new DataView(buffer),
                channels = [], i, sample, offset = 0, pos = 0;
            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
            setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157);
            setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
            setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
            setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164);
            setUint32(length - pos - 4);
            for(i=0; i<abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));
            while(pos < length) {
                for(i=0; i<numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
                    view.setInt16(pos, sample, true); pos += 2;
                }
                offset++;
            }
            return new Blob([buffer], {type: "audio/wav"});
        }

        function showResults(data) {
            const div = document.getElementById('results');
            div.innerHTML = `<h3 style="margin-bottom:15px;">ğŸ“Š Î‘Î½Î¬Î»Ï…ÏƒÎ· Î Î¿ÏƒÎ¿ÏƒÏ„ÏÎ½</h3>` + 
                data.map((item, idx) => `<div class="result-item" style="color:${chartColors[idx].start}">${item.genre}: ${item.probability}%</div>`).join('');
        }

        function renderChart(data) {
            const ctx = document.getElementById('genreChart').getContext('2d');
            
            // Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Gradient Î³Î¹Î± Ï„Î¿ Chart
            const gradients = data.map((_, i) => {
                const g = ctx.createLinearGradient(0, 0, 0, 400);
                g.addColorStop(0, chartColors[i].start);
                g.addColorStop(1, chartColors[i].end);
                return g;
            });

            if (myChart) myChart.destroy();
            myChart = new Chart(ctx, {
                type: 'doughnut', // Î¤Î¿ Doughnut Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï€Î¹Î¿ Î¼Î¿Î½Ï„Î­ÏÎ½Î¿ Î±Ï€ÏŒ Ï„Î¿ Pie
                data: {
                    labels: data.map(i => i.genre),
                    datasets: [{
                        data: data.map(i => i.probability),
                        backgroundColor: gradients,
                        hoverOffset: 20,
                        borderWidth: 0
                    }]
                },
                options: { 
                    responsive: true, 
                    cutout: '70%', // ÎšÎ¬Î½ÎµÎ¹ Ï„Î·Î½ Ï„ÏÏÏ€Î± ÏƒÏ„Î· Î¼Î­ÏƒÎ·
                    plugins: { 
                        legend: { position: 'bottom', labels: { usePointStyle: true, padding: 20 } } 
                    } 
                }
            });
        }
    </script>
</body>
</html>
